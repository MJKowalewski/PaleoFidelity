---
title: "PaleoFidelity"
author: "Michal Kowalewski"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PaleoFidelity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The package "PaleoFidelity" carries out common types of fidelity analyses (live-dead comparisons). The package is specifically designed for compositional data that represent specimen counts of taxa with separate tallies for live and dead components of each sample. The package can be used for a single site (one live-dead comparison), but it is probably more useful when sets of sites need to be analyzed. A grouping factor can be provided to split sites into two or more subsets and carry out comparative analyses across groups. An additional grouping factor that splits species/taxa into subsets can also be provided to assess how fidelity varies across major taxonomic, ecological or taphonomic groups within the analyzed data.

Currently, PaleoFidelity allows users to carry the following analyses (discussed in detail below):

1. __FidelityEst__ function performs compositional fidelity analysis based on a correlation measure, a similarity measure, and an integrated fidelity metric.

2. __FidelityDiv__ function performs alpha diversity and evenness analysis (live-dead offsets in standardized diversity and evenness).

3. __Beta diversity__ analysis assessing sample-standardized offsets in compositional heterogeneity across sites. (FORTHCOMING)

In addition, the following custom plotting functions are provided:

1. __SJPlot__ function to plot a fidelity cross-plot of Correlation and Similarity measures of fidelity 

2. __AlphaPlot__ function to plot a fidelity cross-plot of live-dead offsets in alpha diversity and eveness 

## Installing PaleoFidelity Package

Currently the package can be only installed from github. Use the following set of statements to install PaleoFidelity package.

library(devtools)

devtools::install_github('mjkowalewski/PaleoFidelity')

If you do not have the devtools library already installed, run the following statement in r first: install.packages('devtools')

## Example dataset

The example dataset included in the package illustrates the type of live-dead data most suitable for comopsitional fidelity analyses.

```{r data example}
library(PaleoFidelity)
str(FidData) # check the structure of the example dataset
```

The example dataset is assembled as a single object (a list with 4 items), but your data can be a set of separate _R_ objects, as long as they conform to package requirements. Specifically, the live and dead datasets must be formatted as matrices (my.data2 <- as.matrix(mydata) should do the trick). And the two categorical variables that can be passed through need to be univariate factors.

Let's first explore the example dataset.

```{r fidelity estimates}
out1 <- FidelityEst(live=FidData$live, dead=FidData$dead, gp=FidData$habitat, n.filters=30, dbzero=F, iter=999)
out1$observed.means
```

When the data include multiple sites that can be grouped into subsets, the function will report mean fidelity estimates for total data and each group. Three measures are reported: a correlation measure (default=Spearman), a similarity measure (default=Jaccard-Chao), and a combined fidelity measure (fid.index). Fid.index is a sqrt(2)-scaled Euclidean distance from perfect fidelity (correlation=1, simlarity=1). When fid.index = 0, fidelity is perfect; when fid.index=1, live-dead assemblages are completely disassociated (correlation=0, similarity=0); and when fid.index > 1 an inverse correlation between live and dead taxa may be present.

Note also that correlation can be computed with double zeroes included or excluded. In this example, double zeroes were kept (dbzero=F).

The function outputs (among others) a summary that evaluates the data against a 'Perfect Fidelity' model in which departures from perfect fidelity are due solely to sampling a perfectly congruent live-dead system.

```{r fidelity estimates part 2}
out1$PF.stats
```

If grouping factor 'gp' is provided, per group evaluations are also possible.

```{r fidelity estimates part 3}
out1$gp.prob
```

To explore data visually use SJPlot function. In its default form, this function produces a bubble plot with points scaled by the sample size of the smaller of the two (live or dead) compared samples.

```{r classic fidelity plot}
SJPlot(out1, gpcol=c('aquamarine3', 'coral3'))
```

Set bubble plot to FALSE to plot unscaled symbols.

```{r classic fidelity plot 2}
SJPlot(out1, gpcol=c('aquamarine3', 'coral3'), bubble=F)
```

To evaluate live-dead fidelity in terms of alpha diversity and evenness, use FidelityDiv function. For example:

```{r alpha 1}
out2 <- FidelityDiv(FidData$live, FidData$dead, iter=1000)
str(out2)
```

To visualize those results call function AlphaPlot.

```{r plot alpha 1}
AlphaPlot(out2)
```

When sites are categorized into groups, alpha diversity/evenness analyses include by group analyses. 

```{r alpha 2}
out3 <- FidelityDiv(FidData$live, FidData$dead, FidData$habitat, CI=0.95, iter=1000)
str(out3)
```

By-group plotting can be produced using AlphaPlot

```{r plot alpha 2}
AlphaPlot(out3, col.gp=c('aquamarine3', 'coral3'), bgpt='beige', pch=22)
```

